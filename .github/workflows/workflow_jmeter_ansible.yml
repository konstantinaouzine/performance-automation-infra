name: Load Test - JMeter Ansible
run-name: "JMeter: ${{ github.event.inputs.test_file || 'test_app_load_only.jmx' }}"

on:
  workflow_dispatch:
    inputs:
      test_file:
        description: 'JMX file name (with no path, can be without extension)'
        required: true
        default: 'test_app_load_only.jmx'
      email_to:
        description: 'Emails for report (use comma)'
        required: false
        default: ''

jobs:
  run-ansible-jmeter:
    runs-on: [self-hosted, ansible, jmeter]
    timeout-minutes: 40
    env:
      # Use GitHub expression so путь разворачивается корректно, не буквальная строка
      LOGS_DIR: ${{ github.workspace }}/jmeter_logs
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Debug workspace & list tests
        run: |
          echo "GITHUB_WORKSPACE=$GITHUB_WORKSPACE"
          ls -1 $GITHUB_WORKSPACE/ansible_jmeter/tests || { echo 'tests dir missing'; exit 1; }

      - name: Ensure Ansible
        run: |
          if ! command -v ansible-playbook >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y ansible python3-jmespath
          fi
          ansible --version

      - name: Ensure kubectl
        run: |
          if ! command -v kubectl >/dev/null 2>&1; then
            curl -sLO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
            chmod +x kubectl
            sudo mv kubectl /usr/local/bin/
          fi
          kubectl version --client --output=yaml || true

      - name: Activate minikube docker-env (if available)
        run: |
          if command -v minikube >/dev/null 2>&1; then
            echo "Activating minikube docker-env";
            eval $(minikube docker-env)
            docker info 2>/dev/null | grep -i 'server version' || true
          else
            echo "minikube not found - using default docker context"
          fi

      - name: Run Ansible JMeter playbook
        id: ansible_run
        run: |
          set -e
          TEST_FILE="${{ github.event.inputs.test_file }}"
          if [[ "$TEST_FILE" != *.jmx ]]; then TEST_FILE="${TEST_FILE}.jmx"; fi
          mkdir -p "$LOGS_DIR"
          echo "Using LOGS_DIR=$LOGS_DIR"
          kubectl delete job -n load -l app=jmeter-loadgen --ignore-not-found || true
          ansible-playbook ansible_jmeter/jmeter_play.yml \
            -e jmeter_test_file="$TEST_FILE" \
            -e jmeter_local_logs_dir="$LOGS_DIR" || { echo 'Playbook failed'; exit 1; }
          echo 'After playbook directory tree:'
          find "$LOGS_DIR" -maxdepth 2 -type f -name run.meta -printf 'META %p\n' || true

      - name: Discover run dir from metadata (fallback)
        id: discover
        run: |
          set -e
          if [ ! -d "$LOGS_DIR" ]; then echo 'No logs dir (discover)'; exit 0; fi
          META=$(find "$LOGS_DIR" -maxdepth 2 -type f -name run.meta | head -1 || true)
          if [ -n "$META" ]; then
            RUN_DIR=$(dirname "$META")
            echo "Found run dir via run.meta: $RUN_DIR"
            echo "latest_dir=$RUN_DIR" >> $GITHUB_OUTPUT
          else
            echo 'No run.meta found yet'
          fi

      - name: Locate latest run directory
        id: locate
        run: |
          set -e
          if [ ! -d "$LOGS_DIR" ]; then echo "No logs dir" >&2; exit 1; fi
          echo 'Existing entries:'
          ls -l "$LOGS_DIR" || true
          # Prefer metadata-derived value first
          if [ -n "${{ steps.discover.outputs.latest_dir }}" ]; then
            LATEST='${{ steps.discover.outputs.latest_dir }}'
          else
            LATEST=$(ls -1dt "$LOGS_DIR"/*/ 2>/dev/null | head -1 | sed 's:/*$::')
          fi
          # Fallback to symlink 'latest'
          if [ -z "$LATEST" ] && [ -L "$LOGS_DIR/latest" ]; then
            LATEST=$(readlink -f "$LOGS_DIR/latest")
          fi
          # Fallback to any directory if glob with slash failed
          if [ -z "$LATEST" ]; then
            LATEST=$(find "$LOGS_DIR" -maxdepth 1 -mindepth 1 -type d | sort -r | head -1)
          fi
          echo "Latest run dir: $LATEST"
          echo "latest_dir=$LATEST" >> $GITHUB_OUTPUT
          ls -1 "$LATEST" || true

      - name: SLA & summary
        id: sla
        run: |
          set -euo pipefail
          LATEST='${{ steps.locate.outputs.latest_dir }}'
          if [ -z "$LATEST" ] || [ ! -d "$LATEST" ]; then echo 'No run dir'; exit 1; fi
          JTL="$LATEST/results.jtl"
          if [ ! -f "$JTL" ]; then echo 'No results.jtl found'; exit 1; fi
          echo "Using LATEST=$LATEST"
          echo '--- LAST 10 LINES ---'
          tail -n 10 "$JTL" || true

          echo '--- JTL HEADER ---'
          head -1 "$JTL" || true

          # Detect XML vs CSV
          if grep -q '<sample ' "$JTL"; then
            FORMAT=xml
            TOTAL=$(grep -c '<sample ' "$JTL" || echo 0)
            ERR=$(grep -c '<sample [^>]*s="false"' "$JTL" || echo 0)
          else
            FORMAT=csv
            # Strip CR, ignore blank lines. Assume first line header if contains 'success'
            HEADER=$(head -1 "$JTL" | tr -d '\r') || HEADER=""
            if echo "$HEADER" | grep -qi 'success'; then
              # Count data lines (exclude header & blanks)
              TOTAL=$(tail -n +2 "$JTL" | tr -d '\r' | grep -cv '^$' || echo 0)
              ERR=$(tail -n +2 "$JTL" | tr -d '\r' | grep -c ',false,' || echo 0)
            else
              # Fallback: count all non-empty lines
              TOTAL=$(grep -cv '^$' "$JTL" || echo 0)
              ERR=0
            fi
          fi

          # Sanitize numeric (remove anything after first non-digit)
          TOTAL=$(echo "$TOTAL" | sed 's/[^0-9].*$//')
          ERR=$(echo "$ERR" | sed 's/[^0-9].*$//')

          if [ -z "$TOTAL" ] || ! echo "$TOTAL" | grep -Eq '^[0-9]+$'; then TOTAL=0; fi
          if [ -z "$ERR" ]   || ! echo "$ERR"   | grep -Eq '^[0-9]+$'; then ERR=0; fi

          if [ "$TOTAL" -eq 0 ]; then
            PCT="0.00"
          else
            # Use awk for percentage
            PCT=$(awk -v e="$ERR" -v t="$TOTAL" 'BEGIN{ if(t==0){print "0.00"} else {printf "%.2f", (e/t*100)} }') || PCT="0.00"
          fi

          echo "Format: $FORMAT Total=$TOTAL Errors=$ERR Error%=$PCT"
          echo "Samples: $TOTAL Errors: $ERR ($PCT%)"
          # SLA: fail if >5%
          if awk -v p="$PCT" 'BEGIN{exit (p>5)?0:1}'; then
            echo 'SLA FAIL >5% errors' >&2
            # publish outputs before exit
            echo "total=$TOTAL" >> $GITHUB_OUTPUT
            echo "errors=$ERR" >> $GITHUB_OUTPUT
            echo "error_pct=$PCT" >> $GITHUB_OUTPUT
            echo "format=$FORMAT" >> $GITHUB_OUTPUT
            exit 1
          else
            echo 'SLA OK'
            echo "total=$TOTAL" >> $GITHUB_OUTPUT
            echo "errors=$ERR" >> $GITHUB_OUTPUT
            echo "error_pct=$PCT" >> $GITHUB_OUTPUT
            echo "format=$FORMAT" >> $GITHUB_OUTPUT
          fi

      - name: Notify Teams (success)
        if: ${{ success() }}
        env:
          TEAMS_WEBHOOK: ${{ secrets.TEAMS_WEBHOOK }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          TOTAL: ${{ steps.sla.outputs.total }}
          ERRORS: ${{ steps.sla.outputs.errors }}
          ERROR_PCT: ${{ steps.sla.outputs.error_pct }}
        run: |
          if [ -z "$TEAMS_WEBHOOK" ]; then echo 'No TEAMS_WEBHOOK secret set, skipping.'; exit 0; fi
          cat > payload.json <<EOF
          {
            "@type": "MessageCard",
            "@context": "http://schema.org/extensions",
            "summary": "JMeter Load Test Result",
            "themeColor": "2EB886",
            "title": "JMeter Load Test: SUCCESS",
            "sections": [{
               "facts": [
                 {"name": "Repo", "value": "${{ github.repository }}"},
                 {"name": "Workflow", "value": "${{ github.workflow }}"},
                 {"name": "Run", "value": "#${{ github.run_number }}"},
                 {"name": "Samples", "value": "$TOTAL"},
                 {"name": "Errors", "value": "$ERRORS"},
                 {"name": "Error %", "value": "$ERROR_PCT"}
               ],
               "text": "SLA OK (<=5% errors)."
            }],
            "potentialAction": [{
               "@type": "OpenUri",
               "name": "View Run",
               "targets": [{"os": "default", "uri": "$RUN_URL"}]
            }]
          }
          EOF
          curl -s -H 'Content-Type: application/json' -d @payload.json "$TEAMS_WEBHOOK" || echo 'Teams webhook post failed'

      - name: Notify Teams (failure)
        if: ${{ failure() }}
        env:
          TEAMS_WEBHOOK: ${{ secrets.TEAMS_WEBHOOK }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          TOTAL: ${{ steps.sla.outputs.total }}
          ERRORS: ${{ steps.sla.outputs.errors }}
          ERROR_PCT: ${{ steps.sla.outputs.error_pct }}
        run: |
          if [ -z "$TEAMS_WEBHOOK" ]; then echo 'No TEAMS_WEBHOOK secret set, skipping.'; exit 0; fi
          cat > payload.json <<EOF
          {
            "@type": "MessageCard",
            "@context": "http://schema.org/extensions",
            "summary": "JMeter Load Test Result",
            "themeColor": "C0382B",
            "title": "JMeter Load Test: FAILURE",
            "sections": [{
               "facts": [
                 {"name": "Repo", "value": "${{ github.repository }}"},
                 {"name": "Workflow", "value": "${{ github.workflow }}"},
                 {"name": "Run", "value": "#${{ github.run_number }}"},
                 {"name": "Samples", "value": "$TOTAL"},
                 {"name": "Errors", "value": "$ERRORS"},
                 {"name": "Error %", "value": "$ERROR_PCT"}
               ],
               "text": "SLA FAIL (>5% errors)."
            }],
            "potentialAction": [{
               "@type": "OpenUri",
               "name": "View Run",
               "targets": [{"os": "default", "uri": "$RUN_URL"}]
            }]
          }
          EOF
          curl -s -H 'Content-Type: application/json' -d @payload.json "$TEAMS_WEBHOOK" || echo 'Teams webhook post failed'

      - name: Email report
        if: ${{ always() && github.event.inputs.email_to != '' && secrets.SMTP_SERVER != '' && secrets.SMTP_USERNAME != '' && secrets.SMTP_PASSWORD != '' }}
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.SMTP_SERVER }}
          server_port: ${{ secrets.SMTP_PORT || 587 }}
          username: ${{ secrets.SMTP_USERNAME }}
          password: ${{ secrets.SMTP_PASSWORD }}
          subject: "JMeter Load Test ${{ job.status }} | ${{ github.repository }} #${{ github.run_number }}"
          to: ${{ github.event.inputs.email_to }}
          from: ${{ secrets.SMTP_FROM || 'loadtest-bot@example.com' }}
          secure: true
          attachments: |
            ${{ steps.locate.outputs.latest_dir }}/results.jtl
            ${{ steps.locate.outputs.latest_dir }}/jmeter.log
          body: |
            Repository: ${{ github.repository }}
            Workflow: ${{ github.workflow }}
            Run: #${{ github.run_number }}
            Run URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

            Status: ${{ job.status }}
            Samples: ${{ steps.sla.outputs.total }}
            Errors: ${{ steps.sla.outputs.errors }}
            Error %: ${{ steps.sla.outputs.error_pct }}
            Format: ${{ steps.sla.outputs.format }}

            (Automated email)

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: jmeter-ansible-run
          path: |
            ${{ steps.locate.outputs.latest_dir }}/results.jtl
            ${{ steps.locate.outputs.latest_dir }}/jmeter.log
            ${{ steps.locate.outputs.latest_dir }}

      - name: Finish
        run: echo "Done."
